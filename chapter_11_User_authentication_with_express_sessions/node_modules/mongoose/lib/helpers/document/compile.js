          this.$__.getters = {};
      '_doc',
          Object.defineProperty(nested, documentSchemaSymbol, {
  return result;
          Object.defineProperty(nested, '$__schema', {
const utils = require('../../utils');
      '$locals',
 * exports
      return;
              });
              });
            value: true
          nested.$__.nestedPath = path;
    result[key] = Object.getOwnPropertyDescriptor(object, key);
exports.defineKey = defineKey;
          });
          });
          });
          });
          });
          });
          });
          });
          });
          });
      '__index',
function defineKey(prop, subprops, prototype, prefix, keys, options) {
        return this[getSymbol].call(this.$__[scopeSymbol] || this, path);
    if (skip) {
// gets descriptors for all properties of `object`
      '$isDocumentArrayElement'
            value: this
                virtuals: get(_this, 'schema.options.toJSON.virtuals', null)
exports.compile = compile;
}
}
}
          Object.defineProperty(nested, '$__parent', {
        }
        }
        }
      enumerable: true,
      enumerable: true,
  } else {
const get = require('../../helpers/get');
    Object.defineProperty(prototype, prop, {
    Object.defineProperty(prototype, prop, {
      configurable: true,
      configurable: true,
    result[key].enumerable = false;
          const _isEmptyOptions = Object.freeze({
  const len = keys.length;
      (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type));
    defineKey(key, subprops, proto, prefix, keys, options);
        return this.$__.getters[path];
  const result = {};
        const _this = this;
      get: function() {
      get: function() {
            writable: false,
            writable: false,
            writable: false,
            writable: false,
            writable: false,
            writable: false,
            writable: false,
            writable: false,
            writable: false,
      '__parentArray',
          // can handle them. See gh-9293.
              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
        if (!this.$__.getters) {
  if (subprops) {
  Object.getOwnPropertyNames(object).forEach(function(key) {
// makes all properties non-enumerable to match previous behavior to #2211
              return _this.get(path, null, {
              return _this.get(path, null, {
            }
            }
            }
            }
                virtuals: get(this, 'schema.options.toObject.virtuals', null)
                virtuals: get(this, 'schema.options.toObject.virtuals', null)
        if (v != null && v.$__isNested) {
        this.$set.call(this.$__[scopeSymbol] || this, path, v);
  }
  }
            value: function() {
            value: function() {
            value: function() {
            value: function() {
            enumerable: false,
            enumerable: false,
            enumerable: false,
            enumerable: false,
            enumerable: false,
            enumerable: false,
            enumerable: false,
            enumerable: false,
            enumerable: false,
      set: function(v) {
      set: function(v) {
          this.$__.getters[path] = nested;
          // Convert top-level to POJO, but leave subdocs hydrated so `$set`
            minimize: true,
    });
    });
      'errors',
      }
      }
          v = v.toObject(internalToObjectOptions);
            getters: false,
function getOwnPropertyDescriptors(object) {
  prefix = prefix || '';
 */
 */
 */
              }));
let Document;
          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
          compile(subprops, nested, path, options);
          Object.defineProperty(nested, 'toObject', {
    ].indexOf(key) === -1;
    const hasSubprops = utils.isPOJO(limb) && Object.keys(limb).length &&
  for (let i = 0; i < len; ++i) {
          Object.defineProperty(nested, '$isEmpty', {
        const doc = this.$__[scopeSymbol] || this;
            value: prototype.schema
            value: prototype.schema
            value: prototype.schema
const documentSchemaSymbol = require('../../helpers/symbols').documentSchemaSymbol;
const getSymbol = require('../../helpers/symbols').getSymbol;
    const subprops = hasSubprops ? limb : null;
 * Defines the accessor named prop on the incoming prototype.
  const keys = Object.keys(tree);
  let limb;
        } else if (v instanceof Document && !v.$__isNested) {
          Object.defineProperty(nested, '$__get', {
const scopeSymbol = require('../../helpers/symbols').scopeSymbol;
/*!
/*!
/*!
          v = v.$__get();
      },
      },
            virtuals: false,
      '$__',
const internalToObjectOptions = require('../../options').internalToObjectOptions;
function compile(tree, proto, prefix, options) {
      'isNew',
'use strict';
          }
  let key;
          Object.defineProperty(nested, 'toJSON', {
    limb = tree[key];
    }
          // save scope for nested getters/setters
              return utils.clone(_this.get(path, null, {
            configurable: true,
            configurable: true,
            configurable: true,
            configurable: true,
            configurable: true,
            configurable: true,
            configurable: true,
            configurable: true,
            configurable: true,
        if (!this.$__.getters[path]) {
          if (!prefix) {
          Object.defineProperty(nested, 'schema', {
          Object.defineProperty(nested, '$__isNested', {
            nested.$__[scopeSymbol] = this;
      '$op',
  });
 * Compiles schemas.
            transform: false





























    key = keys[i];
  Document = Document || require('../../document');
  Document = Document || require('../../document');
    const skip = [
  const path = (prefix ? prefix + '.' : '') + prop;
        doc.$set(path, v);
